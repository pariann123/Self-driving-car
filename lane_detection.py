# -*- coding: utf-8 -*-
"""Lane_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OhT7ziytfzummOyhE2avSJetNXqLiKAn
"""

!pip install keras-tuner

import cv2
from skimage.io import imread, imshow, imread_collection, concatenate_images
from skimage.transform import resize
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
import keras
import time

from keras.models import Sequential 
from keras.layers import Conv2D, MaxPool2D, Dropout, Flatten, Dense
from keras.optimizers import Adam
from keras.models import load_model
from keras.callbacks import EarlyStopping, ModelCheckpoint

from sklearn.model_selection import train_test_split

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/MyDrive/MSc Computational Neuroscience, Cognition & AI/MLis2/ML Project/code/YOLOv3_TF2/

code_dir='/content/drive/MyDrive/MSc Computational Neuroscience, Cognition & AI/MLis2/ML Project/code/'
masks_dir=code_dir+'/data/training_data/training_masks/'
masks_list=os.listdir(masks_dir)
print(len(masks_list), masks_list[:5])

# target values
dataframe = pd.read_csv(code_dir+"/YOLOv3_TF2/data/training_norm.csv")
dataset = np.array(dataframe.values)
print(dataset[:5])
MASK_HEIGHT, MASK_WIDTH= 128, 128
INPUT_HEIGHT, INPUT_WIDTH= 88, 128

"""# Make dataset"""

boxes_df = pd.read_csv(code_dir+"YOLOv3_TF2/data/prediction_boxes.csv", header=None)
boxes= np.array(boxes_df.values) #box, car, green light, left signal, person, red light, right signal, tree
print(boxes.shape)
print(boxes[0])

# left signal, right signal
left_boxes=boxes[:,12:16]
right_boxes=boxes[:,24:28]
print(left_boxes.shape, right_boxes.shape)

# CHECK
N=len(masks_list)
print('nb of data', N)
n=np.random.randint(N)
mask_path=os.path.join(masks_dir, str(n)+'.npy')
mask= np.load(mask_path)
mask=mask[MASK_HEIGHT-INPUT_HEIGHT:, :INPUT_WIDTH]
plt.imshow(mask)

"""### First creation of X"""

ANGLE=dataset[:, 1]

#X = np.zeros((N,INPUT_HEIGHT, INPUT_WIDTH, 1), dtype=np.float32)
X, Y=[], []

i=0
for mask in masks_list:
  i+=1
  if i%300==0:
    print(round(i/len( masks_list)*100 ), '%')
  id=int(mask[:-4])-1
  mask_path=os.path.join(masks_dir, mask)
  if id<13797:
    if sum(left_boxes[id,:])==0 and sum(right_boxes[id,:])==0: #remove turn left and right images
      mask= np.load(mask_path)
      mask=mask[MASK_HEIGHT-INPUT_HEIGHT:, :]
      X.append(mask)
      Y.append(ANGLE[id])

print( np.shape(X), np.shape(Y))

X= np.reshape(X, (13253, INPUT_HEIGHT, INPUT_WIDTH, 1))
Y=np.array(Y)
print(np.shape(X), np.shape(Y))

X_path=code_dir+'data/training_data/X_masks.npy'
np.save(X_path, X)
Y_path=code_dir+'data/training_data/Y_masks.npy'
np.save(Y_path, Y)

"""### Upload X"""

X_path=code_dir+'data/training_data/X_masks.npy'
X=np.load(X_path)
Y_path=code_dir+'data/training_data/Y_masks.npy'
Y=np.load(Y_path)

print(np.shape(X), np.shape(Y))

n=np.random.randint(len(X))
mask, angle=X[n], Y[n]
print('predicted angle=', angle)
mask=np.reshape(mask, (INPUT_HEIGHT, INPUT_WIDTH))
plt.imshow(mask)

"""# Create model"""

def nvidia_model():
  model = Sequential()
  model.add(Flatten(input_shape=(INPUT_HEIGHT, INPUT_WIDTH ,1)))
  model.add(Dropout(0.2)) #randomly turn 50% of inputs into 0 45
  model.add(Dense(100,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(50,activation='elu'))
  model.add(Dense(10,activation='elu'))
  model.add(Dense(1)) #outputs the proposed steering angle

  model.compile(loss='mse', optimizer=Adam(lr=0.001))

  return model

def nvidia_model():
  model = Sequential()
  model.add(Flatten( input_shape=(INPUT_HEIGHT, INPUT_WIDTH ,1)))
  #model.add(Dense(5000,activation='elu'))
  model.add(Dense(1000,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(100,activation='elu'))
  model.add(Dense(50,activation='elu'))
  model.add(Dense(10,activation='elu'))
  model.add(Dense(1))# , activation='sigmoid')) #outputs the proposed steering angle
  model.compile(loss="mean_absolute_error", optimizer=Adam(lr=0.00005)) # loss="mean_absolute_error"/ loss="mean_squared_error"

  return model

model = nvidia_model()
print(model.summary())

def nvidia_model():
    model = Sequential(name='Nvidia_Model')
    
    # elu=Expenential Linear Unit, similar to leaky Relu
    # skipping 1st hiddel layer (nomralization layer), as we have normalized the data
    
    # Convolution Layers
    model.add(Conv2D(24, (5, 5), strides=(2, 2), input_shape=(88, 128, 1), activation='elu')) 
    model.add(Conv2D(36, (5, 5), strides=(2, 2), activation='elu')) 
    model.add(Conv2D(48, (5, 5), strides=(2, 2), activation='elu')) 
    model.add(Conv2D(64, (3, 3), activation='elu')) 
    model.add(Dropout(0.2)) # not in original model. added for more robustness
    model.add(Conv2D(64, (3, 3), activation='elu')) 
    
    # Fully Connected Layers
    model.add(Flatten())
    model.add(Dropout(0.2)) # not in original model. added for more robustness
    model.add(Dense(100, activation='elu'))
    model.add(Dense(50, activation='elu'))
    model.add(Dense(10, activation='elu'))
    
    # output layer: turn angle (from 45-135, 90 is straight, <90 turn left, >90 turn right)
    model.add(Dense(1)) 
    
    # since this is a regression problem not classification problem,
    # we use MSE (Mean Squared Error) as loss function
    optimizer = Adam(lr=1e-3) # lr is learning rate
    model.compile(loss='mse', optimizer=optimizer)
    
    return model

model = nvidia_model()

# Only run once
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1, shuffle=True)
print(len(X_train), len(X_test), np.shape(X_train[0]))

"""### Keras Tuner"""

# Only run once
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1, shuffle=True)
print(len(X_train), len(X_test), np.shape(X_train[0]))

from kerastuner.tuners import RandomSearch
from kerastuner.engine.hyperparameters import HyperParameters

def nvidia_model(hp):
  model = keras.Sequential()
  
  for i in range(hp.Int('num_C_layers',2,20)):
    model.add(Conv2D( filters=(hp.Int('C_units_' +str(i), min_value=12, max_value=100, step=32)), 
                               kernel_size=(hp.Choice('conv_kern_'+str(i), values=[3,5])), activation = 'elu'))
  model.add(Flatten( input_shape=(INPUT_HEIGHT, INPUT_WIDTH ,1)))
  for i in range(hp.Int('num_D_layers',2,20)):
    model.add(Dense(units=hp.Int('D_units_' +str(i), min_value=32, max_value=512, step=32), activation = 'elu'))
  model.add(Dropout(rate=hp.Float('dropout_2', min_value=0.0, max_value=0.5, step=0.05)))
  model.add(Dense(1)) #activation func? linear? 
  model.compile(optimizer=keras.optimizers.Adam(hp.Choice('learning_rate', values=[1e-2,1e-3,1e-4])),
                                          loss='mean_squared_error', metrics=['mean_squared_error'])

  return model

tuner_search = RandomSearch(nvidia_model, objective='val_loss',max_trials=5, executions_per_trial=5, directory='project_new7',project_name='kerasTuner_LaneDetection')

tuner_search.search(X_train, Y_train, steps_per_epoch=300, epochs=10, validation_data=(X_test, Y_test))
model_best = tuner_search.get_best_models(num_models=1)[0]
model_best.summary()
tuner_search.get_best_hyperparameters()[0].values

earlystopper = EarlyStopping(patience=5, verbose=1)
checkpointer = ModelCheckpoint('/content/nvidia.h5', verbose=1, save_best_only=True)
history=model_best.fit(X_train,Y_train, batch_size=32 ,epochs=30, validation_data=(X_test, Y_test), callbacks=[earlystopper, checkpointer])

loss=history.history['loss']; val_loss=history.history['val_loss']
plt.plot(loss,'b-', label='loss')
plt.plot(val_loss,'r-', label='val_loss')
plt.legend()
plt.xlabel('epochs')


# Load the best checkpoint model
model_path='/content/nvidia.h5'
model=keras.models.load_model(model_path)


model_path=code_dir+'YOLOv3_TF2/weights/nvidia_new.h5'
model.save(model_path)

earlystopper = EarlyStopping(patience=5, verbose=1)
checkpointer = ModelCheckpoint('/content/nvidia.h5', verbose=1, save_best_only=True)
history=model_best.fit(X_train,Y_train, batch_size=32 ,epochs=30, validation_data=(X_test, Y_test), callbacks=[earlystopper, checkpointer]) #validation_steps=80

"""### Train without augmentation"""

earlystopper = EarlyStopping(patience=5, verbose=1)
checkpointer = ModelCheckpoint('/content/nvidia.h5', verbose=1, save_best_only=True)
history=model.fit(X_train,Y_train, batch_size=32 ,epochs=30, validation_data=(X_test, Y_test), callbacks=[earlystopper, checkpointer]) #validation_steps=80

loss=history.history['loss']; val_loss=history.history['val_loss']
plt.plot(loss,'b-', label='loss')
plt.plot(val_loss,'r-', label='val_loss')
plt.legend()
plt.xlabel('epochs')

"""# Evaluate"""

# Load the best checkpoint model
model_path='/content/nvidia.h5'
model=keras.models.load_model(model_path)

n=np.random.randint(len(X_test))
mask, angle=X_test[n], Y_test[n]

t1=time.perf_counter()
predicted_angle=model.predict(np.reshape(mask,  (1, INPUT_HEIGHT, INPUT_WIDTH,1 ) ))
t2=time.perf_counter()
print('mean time/prediction=', (t2-t1), 's')
print('predicted angle=', float(predicted_angle), '; target angle=', angle)

mask=np.reshape(mask, (INPUT_HEIGHT, INPUT_WIDTH))
plt.imshow(mask)

N=1000
mse=0
for n in range(0,N):
  mask, angle=X_test[n], Y_test[n]
  predicted_angle=model.predict(np.reshape(mask,  (1, INPUT_HEIGHT, INPUT_WIDTH,1 ) ))
  mse+=(float(predicted_angle)-angle)**2
print('mean mse=', mse/N)

"""Save definitly"""

model_path=code_dir+'YOLOv3_TF2/weights/nvidia_0051.h5'
model.save(model_path)

# check the model can be uploaded from the drive
model_path=code_dir+'YOLOv3_TF2/weights/nvidia_0051.h5'
model=keras.models.load_model(model_path)

"""# Turn model

We make two special models to turn right and left
"""

boxes_df = pd.read_csv(code_dir+"YOLOv3_TF2/data/prediction_boxes.csv", header=None)
boxes= np.array(boxes_df.values) #box, car, green light, left signal, person, red light, right signal, tree
print(boxes.shape)
print(boxes[0])

# left signal, right signal
left_boxes=boxes[:,12:16]
right_boxes=boxes[:,24:28]
print(left_boxes.shape, right_boxes.shape)

ANGLE=dataset[:, 1]
X_right, Y_right=[], []
X_left, Y_left=[], []


for i in range(0, len(boxes)):
  if i%500==0:
    print(round(i/len(boxes)*100) , '%')
  if sum(left_boxes[i])>0:
    id=int(i+1)
    mask_name=str(id)+'.npy'
    mask_path=os.path.join(masks_dir, mask_name)
    if os.path.isfile(mask_path):
      mask= np.load(mask_path)
      mask=mask[MASK_HEIGHT-INPUT_HEIGHT:, :]
      X_left.append(mask)
      Y_left.append(ANGLE[i])

  if sum(right_boxes[i])>0:
    id=int(i+1)
    mask_name=str(id)+'.npy'
    mask_path=os.path.join(masks_dir, mask_name)
    if os.path.isfile(mask_path):
      mask= np.load(mask_path)
      mask=mask[MASK_HEIGHT-INPUT_HEIGHT:, :]
      X_right.append(mask)
      Y_right.append(ANGLE[i])

"""### Left"""

# train left
X= np.reshape(X_left, (len(X_left), INPUT_HEIGHT, INPUT_WIDTH, 1))
Y=np.array(Y_left)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1)
print(len(X_train), len(X_test), np.shape(X_train[0]))

"""Fine tune the already trained model"""

model_path=code_dir+'YOLOv3_TF2/weights/nvidia.h5'
model=keras.models.load_model(model_path)
model.compile(loss='mse', optimizer=Adam(lr=0.00001)) # change lr from 0.001 to 0.0001

earlystopper = EarlyStopping(patience=5, verbose=1)
checkpointer = ModelCheckpoint('/content/left.h5', verbose=1, save_best_only=True)
history=model.fit(X_train,Y_train,batch_size=10 ,epochs=20, validation_data=(X_test, Y_test), callbacks=[earlystopper, checkpointer])

model_path='/content/left.h5'
model=keras.models.load_model(model_path)

n=np.random.randint(len(X_test))
mask, angle=X_test[n], Y_test[n]

predicted_angle=model.predict(np.reshape(mask,  (1, INPUT_HEIGHT, INPUT_WIDTH,1 ) ))
print('predicted angle=', float(predicted_angle), '; target angle=', angle)

mask=np.reshape(mask, (INPUT_HEIGHT, INPUT_WIDTH))
plt.imshow(mask)

left_model_path=code_dir+'YOLOv3_TF2/weights/left.h5'
model.save(left_model_path)

"""### Right"""

# train right
X= np.reshape(X_right, (len(X_right), INPUT_HEIGHT, INPUT_WIDTH, 1))
Y=np.array(Y_right)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1)
print(len(X_train), len(X_test), np.shape(X_train[0]))

model_path=code_dir+'YOLOv3_TF2/weights/nvidia.h5'
model=keras.models.load_model(model_path)
model.compile(loss='mse', optimizer=Adam(lr=0.000005)) # change lr from 0.001 to 0.0001

earlystopper = EarlyStopping(patience=10, verbose=1)
checkpointer = ModelCheckpoint('/content/right.h5', verbose=1, save_best_only=True)
history=model.fit(X_train,Y_train,batch_size=5,epochs=20,validation_data=(X_test, Y_test), callbacks=[earlystopper, checkpointer])

model_path='/content/right.h5'
model=keras.models.load_model(model_path)

n=np.random.randint(len(X_test))
mask, angle=X_test[n], Y_test[n]

predicted_angle=model.predict(np.reshape(mask,  (1, INPUT_HEIGHT, INPUT_WIDTH,1 ) ))
print('predicted angle=', float(predicted_angle), '; target angle=', angle)

mask=np.reshape(mask, (INPUT_HEIGHT, INPUT_WIDTH))
plt.imshow(mask)

right_model_path=code_dir+'YOLOv3_TF2/weights/right.h5'
model.save(right_model_path)

"""# Speed """

masks_dir=code_dir+'/data/training_data/masks_road_object/'
masks_list=os.listdir(masks_dir)
print(len(masks_list))
SPEED=dataset[:, 2]
print(SPEED[:5])

"""### Create X, Y"""

#X = np.zeros((N,MASK_HEIGHT, MASK_WIDTH= 128, 128, 1), dtype=np.float32)
X, Y=[], []
i=0
for mask in masks_list:
  i+=1
  if i%500==0:
    print(round(i/len( masks_list)*100 ), '%')
  id=int(mask[:-4])-1
  mask_path=os.path.join(masks_dir, mask)
  if id<13797:
      mask= np.load(mask_path)
      X.append(mask)
      Y.append(int(SPEED[id]))

print( np.shape(X), np.shape(Y))

X= np.reshape(X, (13143, MASK_HEIGHT, MASK_WIDTH, 1))
Y=np.array(Y)
print(np.shape(X), np.shape(Y))

X_path=code_dir+'data/training_data/X_masks_road_object.npy'
np.save(X_path, X)
Y_path=code_dir+'data/training_data/Y_masks_road_object.npy'
np.save(Y_path, Y)

"""### Load X, Y"""

X_path=code_dir+'data/training_data/X_masks_road_object.npy'
X=np.load(X_path)
Y_path=code_dir+'data/training_data/Y_masks_road_object.npy'
Y=np.load(Y_path)
Y=np.array(Y)

print(np.shape(X), np.shape(Y))

n=np.random.randint(len(X))
mask, angle=X[n], Y[n]
print('predicted speed=', angle)
mask=np.reshape(mask, (MASK_HEIGHT, MASK_WIDTH))
plt.imshow(mask)

"""## Model"""

def nvidia_model():
  model = Sequential()
  model.add(Flatten( input_shape=(MASK_HEIGHT, MASK_WIDTH ,1)))
  model.add(Dense(1000,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(100,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(50,activation='elu'))
  model.add(Dense(10,activation='elu'))
  model.add(Dense(1, activation='sigmoid'))
  model.compile(loss='binary_crossentropy', metrics=['accuracy'], optimizer=Adam(lr=0.01))

  return model

def nvidia_model():
  model = Sequential()
  model.add(Flatten( input_shape=(MASK_HEIGHT, MASK_WIDTH ,1)))
  model.add(Dense(1000,activation='elu'))
  # model.add(Dropout(0.2))
  # model.add(Dense(200,activation='elu'))
  model.add(Dense(50,activation='elu'))
  # model.add(Dropout(0.45))
  model.add(Dense(10,activation='elu'))
  model.add(Dense(1, activation='sigmoid'))
  model.compile(loss='binary_crossentropy', metrics=['accuracy'], optimizer=Adam(lr=0.001))

  return model

# model = nvidia_model()
# print(model.summary())

# X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1, shuffle=True)
# print(len(X_train), len(X_test), np.shape(X_train[0]), np.shape(Y_train))

earlystopper = EarlyStopping(patience=5, verbose=1)
checkpointer = ModelCheckpoint('/content/speed.h5', verbose=1, save_best_only=True)
history=model.fit(X_train,Y_train,batch_size=64,epochs=30, validation_data=(X_test, Y_test), callbacks=[earlystopper, checkpointer]) #validation_steps=80

"""## Evaluate"""

model_path='/content/speed.h5'
model=keras.models.load_model(model_path)

import time
n=np.random.randint(len(X_test))
mask, speed=X_test[n], Y_test[n]
t1=time.perf_counter()

predicted_speed=model.predict(np.reshape(mask,  (1, MASK_HEIGHT, MASK_WIDTH,1 ) ))
t2=time.perf_counter()

print('predicted speed=', round(float(predicted_speed)), '; target speed=', speed, 'time=', t2-t1)

mask=np.reshape(mask, (MASK_HEIGHT, MASK_WIDTH))
plt.imshow(mask)

speed_model_path=code_dir+'YOLOv3_TF2/weights/speed.h5'
model.save(speed_model_path)

"""# Draft

"""

def nvidia_model():
  model = Sequential()
  model.add(Conv2D(24, kernel_size= (5,5), strides=(2,2), input_shape=(INPUT_HEIGHT, INPUT_WIDTH ,1), activation='elu'))
  model.add(Conv2D(36, kernel_size= (5,5), strides=(2,2), activation='elu'))
  model.add(Conv2D(48, kernel_size= (5,5), strides=(2,2), activation='elu'))
  model.add(Conv2D(64, kernel_size= (3,3), activation='elu')) 
  model.add(Conv2D(64, kernel_size= (3,3), activation='elu'))
  model.add(Dropout(0.2)) #randomly turn 50% of inputs into 0 45

  model.add(Flatten())
  model.add(Dense(100,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(50,activation='elu'))
  model.add(Dense(10,activation='elu'))
  model.add(Dense(1)) #outputs the proposed steering angle

  model.compile(loss='mse', optimizer=Adam(lr=0.001))

  return model

def nvidia_model():
  model = Sequential()
  model.add(Flatten( input_shape=(INPUT_HEIGHT, INPUT_WIDTH ,1)))
  model.add(Dense(1000,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(100,activation='elu'))
  model.add(Dropout(0.2))
  model.add(Dense(50,activation='elu'))
  model.add(Dense(10,activation='elu'))
  model.add(Dense(1))# , activation='sigmoid')) #outputs the proposed steering angle

  model.compile(loss='mse', optimizer=Adam(lr=0.001))

  return model